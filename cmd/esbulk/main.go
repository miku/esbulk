// Copyright 2021 by Leipzig University Library, http://ub.uni-leipzig.de
//                   The Finc Authors, http://finc.info
//                   Martin Czygan, <martin.czygan@uni-leipzig.de>
//
// This file is part of some open source application.
//
// Some open source application is free software: you can redistribute
// it and/or modify it under the terms of the GNU General Public
// License as published by the Free Software Foundation, either
// version 3 of the License, or (at your option) any later version.
//
// Some open source application is distributed in the hope that it will
// be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
//
// @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>

package main

import (
	"flag"
	"log"
	"os"
	"runtime"
	"strings"
	"time"

	"github.com/miku/esbulk"
)

var (
	version         = flag.Bool("v", false, "prints current program version")
	cpuprofile      = flag.String("cpuprofile", "", "write cpu profile to file")
	memprofile      = flag.String("memprofile", "", "write heap profile to file")
	indexName       = flag.String("index", "", "index name")
	opType          = flag.String("optype", "index", "optype (index - will replace existing data, create - will only create a new doc, update - create new or update existing data)")
	docType         = flag.String("type", "", "elasticsearch doc type (deprecated since ES7)")
	batchSize       = flag.Int("size", 1000, "bulk batch size")
	numWorkers      = flag.Int("w", runtime.NumCPU(), "number of workers to use")
	verbose         = flag.Bool("verbose", false, "output basic progress")
	skipbroken      = flag.Bool("skipbroken", false, "skip broken json")
	gzipped         = flag.Bool("z", false, "unzip gz'd file on the fly")
	mapping         = flag.String("mapping", "", "mapping string or filename to apply before indexing")
	config          = flag.String("c", "", "create index mappings, settings, aliases, https://is.gd/3zszeu")
	purge           = flag.Bool("purge", false, "purge any existing index before indexing")
	purgePause      = flag.Duration("purge-pause", 1*time.Second, "pause after purge")
	idfield         = flag.String("id", "", "name of field to use as id field, by default ids are autogenerated")
	user            = flag.String("u", "", "http basic auth username:password, like curl -u")
	zeroReplica     = flag.Bool("0", false, "set the number of replicas to 0 during indexing")
	refreshInterval = flag.String("r", "1s", "Refresh interval after import")
	pipeline        = flag.String("p", "", "pipeline to use to preprocess documents")
	serverFlags     esbulk.ArrayFlags
)

func main() {
	flag.Var(&serverFlags, "server", "elasticsearch server, this works with https as well")
	flag.Parse()
	var (
		file               *os.File = os.Stdin
		username, password string
	)
	if flag.NArg() > 0 {
		f, err := os.Open(flag.Arg(0))
		if err != nil {
			log.Fatalln(err)
		}
		defer f.Close()
		file = f
	}
	if len(*user) > 0 {
		parts := strings.Split(*user, ":")
		if len(parts) != 2 {
			log.Fatal("http basic auth syntax is: username:password")
		}
		username = parts[0]
		password = parts[1]
	}
	runner := &esbulk.Runner{
		BatchSize:       *batchSize,
		Config:          *config,
		CpuProfile:      *cpuprofile,
		DocType:         *docType,
		File:            file,
		FileGzipped:     *gzipped,
		IdentifierField: *idfield,
		IndexName:       *indexName,
		Mapping:         *mapping,
		MemProfile:      *memprofile,
		NumWorkers:      *numWorkers,
		OpType:          *opType,
		Password:        password,
		Pipeline:        *pipeline,
		Purge:           *purge,
		PurgePause:      *purgePause,
		RefreshInterval: *refreshInterval,
		Servers:         serverFlags,
		ShowVersion:     *version,
		SkipBroken:      *skipbroken,
		Username:        username,
		Verbose:         *verbose,
		ZeroReplica:     *zeroReplica,
	}
	if err := runner.Run(); err != nil {
		log.Fatal(err)
	}
}
